

-----

### **Instructions for Updating Your Project**

Follow these steps to integrate the updated code into your `MatrixLocker` project.

#### **Step 1: Add New Files**

First, add the following **new files** to your project. These files introduce secure password storage and sound effects management.

1.  **Create a new Swift file** named `KeychainHelper.swift` inside the `Utils` group in Xcode and add the following code. This class will handle all interactions with the system's secure Keychain.

2.  **Create another new Swift file** named `SoundManager.swift` inside the `Utils` group and add the code below. This will manage the playback of sound effects.

#### **Step 2: Update Existing Files**

Next, **replace the entire contents** of the following existing files with the updated code provided below. These changes incorporate the new features, fix bugs, and improve the overall structure.

  * `MatrixLocker/Utils/ActivityMonitor.swift`
  * `MatrixLocker/Models/UserSettings.swift`
  * `MatrixLocker/Controllers/LockScreenViewController.swift`
  * `MatrixLocker/AppDelegate.swift`

#### **Step 3: Refactor Your Settings View**

I have refactored the settings into a single, more manageable view controller.

1.  **Delete** the following files from your project, as they are now redundant:

      * `GeneralSettingsViewController.swift`
      * `MatrixSettingsViewController.swift`
      * `AboutViewController.swift`
      * `XcodeSettingsViewController.swift`

2.  **Replace the code** in `SettingsViewController.swift` with the new, unified code provided below.

3.  **Update your Storyboard (`Main.storyboard`)**:

      * Open `Main.storyboard` and select the `SettingsViewController`.
      * Remove all UI elements related to the old, separate settings panes.
      * Add a `NSTabView` to the `SettingsViewController`.
      * Create three tabs: "General", "Matrix", and "Security".
      * Populate each tab with the corresponding UI controls (sliders, switches, color wells) as defined in the new `SettingsViewController.swift` outlets. Make sure to connect all the `@IBOutlet`s from the new code to your UI elements in the Storyboard. This unification eliminates code duplication and simplifies state management.

-----

### **New File: `KeychainHelper.swift`**

**(Add to `MatrixLocker/Utils/`)**

```swift
import Foundation
import Security

/// A helper class for securely storing and retrieving data from the system Keychain.
/// This is used to manage the user's lock password, avoiding insecure storage like UserDefaults.
final class KeychainHelper {
    
    static let shared = KeychainHelper()
    private let service = "com.yourcompany.MatrixLocker" // IMPORTANT: Use your app's bundle identifier

    private init() {}

    /// Saves a string value to the Keychain for a specific account.
    ///
    /// - Parameters:
    ///   - value: The string to save.
    ///   - account: The account key to associate with the value.
    /// - Returns: `true` if saving was successful, `false` otherwise.
    func save(_ value: String, for account: String) -> Bool {
        guard let data = value.data(using: .utf8) else { return false }
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: account,
            kSecValueData as String: data
        ]
        
        // Delete any existing item before saving a new one
        SecItemDelete(query as CFDictionary)
        
        let status = SecItemAdd(query as CFDictionary, nil)
        return status == errSecSuccess
    }

    /// Retrieves a string value from the Keychain for a specific account.
    ///
    /// - Parameter account: The account key for the value to retrieve.
    /// - Returns: The stored string, or `nil` if it's not found or an error occurs.
    func get(for account: String) -> String? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: account,
            kSecReturnData as String: kCFBooleanTrue!,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var dataTypeRef: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
        
        if status == errSecSuccess {
            guard let data = dataTypeRef as? Data else { return nil }
            return String(data: data, encoding: .utf8)
        } else {
            return nil
        }
    }

    /// Deletes a value from the Keychain for a specific account.
    ///
    /// - Parameter account: The account key for the value to delete.
    /// - Returns: `true` if deletion was successful, `false` otherwise.
    func delete(for account: String) -> Bool {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: account
        ]
        
        let status = SecItemDelete(query as CFDictionary)
        return status == errSecSuccess
    }
}
```

-----

### **New File: `SoundManager.swift`**

**(Add to `MatrixLocker/Utils/`)**

```swift
import Cocoa
import AVFoundation

/// Manages the playback of sound effects for the application.
final class SoundManager {
    static let shared = SoundManager()
    private var audioPlayer: AVAudioPlayer?

    private init() {}

    enum SoundEffect {
        case lock
        case unlock
        case failedAttempt
    }
    
    /// Plays a specified sound effect if sound effects are enabled in user settings.
    ///
    /// - Parameter effect: The `SoundEffect` to play.
    func play(effect: SoundEffect) {
        guard UserSettings.shared.matrixSoundEffects else { return }

        var soundName: String?
        
        switch effect {
        case .lock:
            soundName = "Tink" // Example system sound
        case .unlock:
            soundName = "Submarine" // Example system sound
        case .failedAttempt:
            soundName = "Basso" // Example system sound
        }
        
        if let soundName = soundName, let sound = NSSound(named: soundName) {
            sound.play()
        }
    }
}
```

-----

### **Updated File: `ActivityMonitor.swift`**

**(Replace in `MatrixLocker/Utils/`)**

```swift
import Cocoa

class ActivityMonitor {
    private enum State {
        case stopped
        case monitoring
        case readyToLock
        case activateNowCountdown
    }

    private var state: State = .stopped
    private var activityMonitor: Any?
    private var inactivityTimer: Timer?

    init() {
        NotificationCenter.default.addObserver(self, selector: #selector(startMonitoring), name: Notifications.startMonitoring, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(stopMonitoring), name: Notifications.stopMonitoring, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(activateNow), name: Notifications.activateNow, object: nil)
    }

    deinit {
        NotificationCenter.default.removeObserver(self)
        stopMonitoring()
    }

    @objc func startMonitoring() {
        guard state == .stopped || state == .activateNowCountdown else { return }
        print("Activity Monitor: Started")
        state = .monitoring
        resetInactivityTimer()
    }

    @objc func stopMonitoring() {
        guard state != .stopped else { return }
        print("Activity Monitor: Stopped")
        state = .stopped
        inactivityTimer?.invalidate()
        inactivityTimer = nil
        if let monitor = activityMonitor {
            NSEvent.removeMonitor(monitor)
            activityMonitor = nil
        }
    }

    @objc func activateNow() {
        print("Activity Monitor: Activating now with 10-second countdown.")
        stopMonitoring() // Stop any current monitoring
        state = .activateNowCountdown
        
        // Start a 10-second timer. This timer will NOT be reset by activity.
        inactivityTimer = Timer.scheduledTimer(withTimeInterval: 10.0, repeats: false) { [weak self] _ in
            self?.inactivityTimerDidFire()
        }
        // No activity listening during the `activateNow` countdown.
    }

    private func resetInactivityTimer() {
        inactivityTimer?.invalidate()
        let timeout = UserSettings.shared.inactivityTimeout
        inactivityTimer = Timer.scheduledTimer(withTimeInterval: timeout, repeats: false) { [weak self] _ in
            self?.inactivityTimerDidFire()
        }
        startListeningForActivity()
    }

    private func inactivityTimerDidFire() {
        print("Activity Monitor: Inactivity timeout reached. Ready to lock.")
        state = .readyToLock
        // Stop listening for activity that resets the timer
        if let monitor = activityMonitor {
            NSEvent.removeMonitor(monitor)
            activityMonitor = nil
        }
        // Start listening for the next activity to trigger the lock
        startListeningForLockTrigger()
    }

    private func startListeningForActivity() {
        if activityMonitor != nil {
            NSEvent.removeMonitor(activityMonitor!)
        }
        let eventMask: NSEvent.EventTypeMask = [.mouseMoved, .leftMouseDown, .rightMouseDown, .otherMouseDown, .keyDown, .scrollWheel]
        activityMonitor = NSEvent.addGlobalMonitorForEvents(matching: eventMask) { [weak self] _ in
            self?.handleActivity()
        }
    }

    private func startListeningForLockTrigger() {
        if activityMonitor != nil {
            NSEvent.removeMonitor(activityMonitor!)
        }
        let eventMask: NSEvent.EventTypeMask = [.mouseMoved, .leftMouseDown, .rightMouseDown, .otherMouseDown, .keyDown, .scrollWheel]
        activityMonitor = NSEvent.addGlobalMonitorForEvents(matching: eventMask) { [weak self] _ in
            self?.triggerLock()
        }
    }

    private func handleActivity() {
        // Only reset the timer if we are in the standard monitoring state.
        if state == .monitoring {
            print("Activity detected, resetting timer.")
            DispatchQueue.main.async { // Ensure timer is handled on the main thread
                self.resetInactivityTimer()
            }
        }
    }

    private func triggerLock() {
        if state == .readyToLock {
            print("Activity detected in ready state. Locking screen.")
            DispatchQueue.main.async {
                NotificationCenter.default.post(name: Notifications.userDidBecomeInactive, object: nil)
            }
            stopMonitoring()
        }
    }
}
```

-----

### **Updated File: `UserSettings.swift`**

**(Replace in `MatrixLocker/Models/`)**

```swift
import Cocoa

class UserSettings {
    static let shared = UserSettings()
    private let defaults = UserDefaults.standard

    // Keys for UserDefaults to prevent typos
    private struct Keys {
        static let inactivityTimeout = "inactivityTimeout"
        static let matrixCharacterColor = "matrixCharacterColor"
        // static let lockPassword = "lockPassword" // REMOVED FOR SECURITY
        static let maxFailedAttempts = "maxFailedAttempts"
        static let lockoutDuration = "lockoutDuration"
        static let enablePasswordProtection = "enablePasswordProtection"
        static let enableAutomaticLock = "enableAutomaticLock"
        static let requirePasswordOnWake = "requirePasswordOnWake"
        static let matrixAnimationSpeed = "matrixAnimationSpeed"
        static let matrixDensity = "matrixDensity"
        static let matrixSoundEffects = "matrixSoundEffects"
        static let showTimeRemaining = "showTimeRemaining"
        static let hideFromDock = "hideFromDock"
        static let startMinimized = "startMinimized"
        
        // Keychain account key
        static let passwordAccount = "userLockPassword"
    }

    private init() {
        // Register default values to ensure the app has a valid state on first launch
        defaults.register(defaults: [
            Keys.inactivityTimeout: 60.0,
            Keys.matrixCharacterColor: try! NSKeyedArchiver.archivedData(withRootObject: NSColor.systemGreen, requiringSecureCoding: false),
            Keys.maxFailedAttempts: 5,
            Keys.lockoutDuration: 300.0,
            Keys.enablePasswordProtection: true,
            Keys.enableAutomaticLock: true,
            Keys.requirePasswordOnWake: true,
            Keys.matrixAnimationSpeed: 1.0,
            Keys.matrixDensity: 0.7,
            Keys.matrixSoundEffects: false,
            Keys.showTimeRemaining: true,
            Keys.hideFromDock: false,
            Keys.startMinimized: false
        ])
    }

    // MARK: - Inactivity Timeout
    var inactivityTimeout: TimeInterval {
        get { return defaults.double(forKey: Keys.inactivityTimeout) }
        set {
            let clampedValue = max(10.0, min(300.0, newValue))
            defaults.set(clampedValue, forKey: Keys.inactivityTimeout)
        }
    }

    // MARK: - Matrix Color
    var matrixCharacterColor: NSColor {
        get {
            guard let data = defaults.data(forKey: Keys.matrixCharacterColor),
                  let color = try? NSKeyedUnarchiver.unarchivedObject(ofClass: NSColor.self, from: data) else {
                return .systemGreen
            }
            return color
        }
        set {
            guard let data = try? NSKeyedArchiver.archivedData(withRootObject: newValue, requiringSecureCoding: false) else { return }
            defaults.set(data, forKey: Keys.matrixCharacterColor)
        }
    }
    
    // MARK: - Security Settings
    var lockPassword: String? {
        return KeychainHelper.shared.get(for: Keys.passwordAccount)
    }
    
    var maxFailedAttempts: Int {
        get { return defaults.integer(forKey: Keys.maxFailedAttempts) }
        set { defaults.set(newValue, forKey: Keys.maxFailedAttempts) }
    }
    
    var lockoutDuration: TimeInterval {
        get { return defaults.double(forKey: Keys.lockoutDuration) }
        set { defaults.set(newValue, forKey: Keys.lockoutDuration) }
    }
    
    var enablePasswordProtection: Bool {
        get { return defaults.bool(forKey: Keys.enablePasswordProtection) }
        set { defaults.set(newValue, forKey: Keys.enablePasswordProtection) }
    }
    
    var enableAutomaticLock: Bool {
        get { return defaults.bool(forKey: Keys.enableAutomaticLock) }
        set { defaults.set(newValue, forKey: Keys.enableAutomaticLock) }
    }
        
    // MARK: - Matrix Visual Settings
    var matrixAnimationSpeed: Double {
        get { return defaults.double(forKey: Keys.matrixAnimationSpeed) }
        set { defaults.set(newValue, forKey: Keys.matrixAnimationSpeed) }
    }
    
    var matrixDensity: Double {
        get { return defaults.double(forKey: Keys.matrixDensity) }
        set { defaults.set(newValue, forKey: Keys.matrixDensity) }
    }
    
    // MARK: - UI/UX Settings
    var matrixSoundEffects: Bool {
        get { return defaults.bool(forKey: Keys.matrixSoundEffects) }
        set { defaults.set(newValue, forKey: Keys.matrixSoundEffects) }
    }
    
    var showTimeRemaining: Bool {
        get { return defaults.bool(forKey: Keys.showTimeRemaining) }
        set { defaults.set(newValue, forKey: Keys.showTimeRemaining) }
    }
    
    var hideFromDock: Bool {
        get { return defaults.bool(forKey: Keys.hideFromDock) }
        set {
            defaults.set(newValue, forKey: Keys.hideFromDock)
            // The AppDelegate should observe this change and handle the UI update.
        }
    }
    
    var startMinimized: Bool {
        get { return defaults.bool(forKey: Keys.startMinimized) }
        set { defaults.set(newValue, forKey: Keys.startMinimized) }
    }
        
    // MARK: - Security Helper Methods
    func setPassword(_ password: String?) {
        guard let password = password, !password.isEmpty else {
            _ = KeychainHelper.shared.delete(for: Keys.passwordAccount)
            return
        }
        _ = KeychainHelper.shared.save(password, for: Keys.passwordAccount)
    }
    
    func checkPassword(_ input: String) -> Bool {
        guard enablePasswordProtection, let savedPassword = lockPassword else {
            return true // Success if password protection is off or no password is set
        }
        // In a real production app, you would use a hashed comparison.
        // For this example, we'll stick to direct comparison of the keychain-stored password.
        return input == savedPassword
    }

    func recordFailedAttempt() {
        failedAttempts += 1
        lastFailedAttempt = Date()
        
        if failedAttempts >= maxFailedAttempts {
            lockoutEndTime = Date().addingTimeInterval(lockoutDuration)
        }
    }
    
    // ... (rest of the UserSettings class remains the same)
    // MARK: - Failed Attempts Management
    
    private struct SecurityKeys {
        static let failedAttempts = "failedAttempts"
        static let lastFailedAttempt = "lastFailedAttempt"
        static let lockoutEndTime = "lockoutEndTime"
    }
    
    var failedAttempts: Int {
        get { return defaults.integer(forKey: SecurityKeys.failedAttempts) }
        set { defaults.set(newValue, forKey: SecurityKeys.failedAttempts) }
    }
    
    private var lastFailedAttempt: Date? {
        get { return defaults.object(forKey: SecurityKeys.lastFailedAttempt) as? Date }
        set { defaults.set(newValue, forKey: SecurityKeys.lastFailedAttempt) }
    }
    
    private var lockoutEndTime: Date? {
        get { return defaults.object(forKey: SecurityKeys.lockoutEndTime) as? Date }
        set { defaults.set(newValue, forKey: SecurityKeys.lockoutEndTime) }
    }
    
    // MARK: - Security Check Methods
    
    func isLockedOut() -> Bool {
        guard let lockoutEnd = lockoutEndTime else { return false }
        return Date() < lockoutEnd
    }
    
    func timeRemainingInLockout() -> TimeInterval {
        guard let lockoutEnd = lockoutEndTime else { return 0 }
        let remaining = lockoutEnd.timeIntervalSince(Date())
        return max(0, remaining)
    }
    
    func attemptLogin(password: String) -> LoginResult {
        if isLockedOut() {
            let remaining = timeRemainingInLockout()
            return .lockedOut(timeRemaining: remaining)
        }
        
        if checkPassword(password) {
            resetFailedAttempts()
            return .success
        } else {
            return handleFailedAttempt()
        }
    }
    
    private func handleFailedAttempt() -> LoginResult {
        failedAttempts += 1
        lastFailedAttempt = Date()
        
        if failedAttempts >= maxFailedAttempts {
            lockoutEndTime = Date().addingTimeInterval(lockoutDuration)
            return .lockedOut(timeRemaining: lockoutDuration)
        } else {
            let remainingAttempts = max(0, maxFailedAttempts - failedAttempts)
            return .failed(attemptsRemaining: remainingAttempts)
        }
    }
    
    func resetFailedAttempts() {
        failedAttempts = 0
        lastFailedAttempt = nil
        lockoutEndTime = nil
    }
    
    // MARK: - Utility Methods
    func formatTimeRemaining(_ timeInterval: TimeInterval) -> String {
        let totalMinutes = Int(timeInterval / 60)
        let seconds = Int(timeInterval.truncatingRemainder(dividingBy: 60))
        
        if totalMinutes > 0 {
            return String(format: "%d min, %d sec", totalMinutes, seconds)
        } else {
            return "\(seconds) seconds"
        }
    }
}

// MARK: - Login Result Enum

enum LoginResult {
    case success
    case failed(attemptsRemaining: Int)
    case lockedOut(timeRemaining: TimeInterval)
    
    var isSuccess: Bool {
        if case .success = self { return true }
        return false
    }
    
    var errorMessage: String {
        switch self {
        case .success:
            return ""
        case .failed(let remaining):
            return "Incorrect password. \(remaining) attempt\(remaining != 1 ? "s" : "") remaining."
        case .lockedOut(let timeRemaining):
            let timeString = UserSettings.shared.formatTimeRemaining(timeRemaining)
            return "Too many failed attempts. Try again in \(timeString)."
        }
    }
}

```

-----

### **Updated File: `LockScreenViewController.swift`**

**(Replace in `MatrixLocker/Controllers/`)**

```swift
import Cocoa
import LocalAuthentication

protocol LockScreenDelegate: AnyObject {
    func didUnlockScreen()
}

class LockScreenViewController: NSViewController {
    weak var delegate: LockScreenDelegate?
    
    private var passwordField: NSSecureTextField!
    private var messageLabel: NSTextField!

    override func viewDidLoad() {
        super.viewDidLoad()
        setupMatrixBackground()
        setupUnlockInterface()
        // Attempt biometrics as soon as the view appears
        attemptSystemAuthentication()
    }

    private func setupMatrixBackground() {
        let matrixView = LockScreenView(frame: self.view.bounds)
        matrixView.autoresizingMask = [.width, .height]
        // You can customize the lock screen matrix effect here if needed
        matrixView.rainColor = UserSettings.shared.matrixCharacterColor
        self.view.addSubview(matrixView, positioned: .below, relativeTo: nil)
        matrixView.startAnimation()
    }
    
    private func setupUnlockInterface() {
        // Create a container with a visual effect view for the frosted glass look
        let containerView = NSVisualEffectView()
        containerView.material = .hudWindow
        containerView.blendingMode = .behindWindow
        containerView.state = .active
        containerView.wantsLayer = true
        containerView.layer?.cornerRadius = 12
        containerView.translatesAutoresizingMaskIntoConstraints = false
        
        let titleLabel = NSTextField(labelWithString: "MATRIX LOCKED")
        titleLabel.font = NSFont(name: "Menlo-Bold", size: 22)
        titleLabel.textColor = .white
        titleLabel.alignment = .center
        
        messageLabel = NSTextField(labelWithString: "Enter password or use Touch ID")
        messageLabel.font = .systemFont(ofSize: 14)
        messageLabel.textColor = .lightGray
        messageLabel.alignment = .center

        passwordField = NSSecureTextField()
        passwordField.placeholderString = "Password"
        passwordField.target = self
        passwordField.action = #selector(passwordEntered)
        passwordField.font = .systemFont(ofSize: 16)
        passwordField.alignment = .center
        
        let unlockButton = NSButton(title: "Unlock", target: self, action: #selector(unlockButtonClicked))
        unlockButton.bezelStyle = .rounded
        
        let stackView = NSStackView(views: [titleLabel, messageLabel, passwordField, unlockButton])
        stackView.orientation = .vertical
        stackView.spacing = 15
        stackView.distribution = .fill
        stackView.translatesAutoresizingMaskIntoConstraints = false

        containerView.addSubview(stackView)
        self.view.addSubview(containerView)
        
        NSLayoutConstraint.activate([
            containerView.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            containerView.centerYAnchor.constraint(equalTo: view.centerYAnchor),
            containerView.widthAnchor.constraint(equalToConstant: 320),
            
            stackView.topAnchor.constraint(equalTo: containerView.topAnchor, constant: 20),
            stackView.bottomAnchor.constraint(equalTo: containerView.bottomAnchor, constant: -20),
            stackView.leadingAnchor.constraint(equalTo: containerView.leadingAnchor, constant: 20),
            stackView.trailingAnchor.constraint(equalTo: containerViw.trailingAnchor, constant: -20),
        ])
    }
    
    @objc private func passwordEntered() {
        checkPassword()
    }

    @objc private func unlockButtonClicked() {
        checkPassword()
    }
    
    private func checkPassword() {
        let password = passwordField.stringValue
        let result = UserSettings.shared.attemptLogin(password: password)
        
        switch result {
        case .success:
            SoundManager.shared.play(effect: .unlock)
            delegate?.didUnlockScreen()
        case .failed(let attemptsRemaining):
            SoundManager.shared.play(effect: .failedAttempt)
            passwordField.stringValue = ""
            messageLabel.stringValue = "Incorrect. \(attemptsRemaining) attempts remaining."
            messageLabel.textColor = .systemRed
            shakeWindow()
        case .lockedOut(let timeRemaining):
            SoundManager.shared.play(effect: .failedAttempt)
            passwordField.stringValue = ""
            passwordField.isEnabled = false
            messageLabel.stringValue = "Locked out. Try again in \(UserSettings.shared.formatTimeRemaining(timeRemaining))."
            messageLabel.textColor = .systemOrange
            startLockoutTimer()
        }
    }
    
    private func startLockoutTimer() {
        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] timer in
            guard let self = self else {
                timer.invalidate()
                return
            }
            
            if !UserSettings.shared.isLockedOut() {
                timer.invalidate()
                self.messageLabel.stringValue = "Enter password or use Touch ID"
                self.messageLabel.textColor = .lightGray
                self.passwordField.isEnabled = true
            } else {
                let remaining = UserSettings.shared.timeRemainingInLockout()
                self.messageLabel.stringValue = "Locked out. Try again in \(UserSettings.shared.formatTimeRemaining(remaining))."
            }
        }
    }

    private func attemptSystemAuthentication() {
        guard UserSettings.shared.enablePasswordProtection else {
            delegate?.didUnlockScreen()
            return
        }
        
        let context = LAContext()
        var error: NSError?
        
        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {
            let reason = "Unlock MatrixLocker"
            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { [weak self] success, _ in
                DispatchQueue.main.async {
                    if success {
                        SoundManager.shared.play(effect: .unlock)
                        self?.delegate?.didUnlockScreen()
                    }
                    // If biometric fails, the user can still type their password.
                }
            }
        }
    }
    
    private func shakeWindow() {
        let animation = CAKeyframeAnimation(keyPath: "transform.translation.x")
        animation.timingFunction = CAMediaTimingFunction(name: .linear)
        animation.duration = 0.5
        animation.values = [-15, 15, -10, 10, -5, 5, 0]
        self.view.window?.contentView?.layer?.add(animation, forKey: "shake")
    }
}
```

-----

### **Updated File: `SettingsViewController.swift`**

**(Replace code and adapt Storyboard)**

```swift
import Cocoa

class SettingsViewController: NSViewController {

    // MARK: - Outlets
    
    // General Tab
    @IBOutlet weak var launchAtLoginSwitch: NSSwitch!
    @IBOutlet weak var hideFromDockSwitch: NSSwitch!
    @IBOutlet weak var startMinimizedSwitch: NSSwitch!

    // Matrix Tab
    @IBOutlet weak var characterColorWell: NSColorWell!
    @IBOutlet weak var animationSpeedSlider: NSSlider!
    @IBOutlet weak var animationSpeedLabel: NSTextField!
    @IBOutlet weak var densitySlider: NSSlider!
    @IBOutlet weak var densityLabel: NSTextField!
    @IBOutlet weak var soundEffectsSwitch: NSSwitch!
    
    // Security Tab
    @IBOutlet weak var automaticLockSwitch: NSSwitch!
    @IBOutlet weak var timeoutSlider: NSSlider!
    @IBOutlet weak var timeoutLabel: NSTextField!
    @IBOutlet weak var passwordProtectionSwitch: NSSwitch!
    @IBOutlet weak var passwordField: NSSecureTextField!
    @IBOutlet weak var setPasswordButton: NSButton!
    @IBOutlet weak var maxAttemptsStepper: NSStepper!
    @IBOutlet weak var maxAttemptsLabel: NSTextField!
    @IBOutlet weak var lockoutDurationSlider: NSSlider!
    @IBOutlet weak var lockoutDurationLabel: NSTextField!

    override func viewDidLoad() {
        super.viewDidLoad()
        loadSettings()
        updateUIState()
    }
    
    private func loadSettings() {
        let settings = UserSettings.shared
        
        // General
        launchAtLoginSwitch.state = LaunchAtLogin.isEnabled ? .on : .off
        hideFromDockSwitch.state = settings.hideFromDock ? .on : .off
        startMinimizedSwitch.state = settings.startMinimized ? .on : .off
        
        // Matrix
        characterColorWell.color = settings.matrixCharacterColor
        animationSpeedSlider.doubleValue = settings.matrixAnimationSpeed
        densitySlider.doubleValue = settings.matrixDensity
        soundEffectsSwitch.state = settings.matrixSoundEffects ? .on : .off
        
        // Security
        automaticLockSwitch.state = settings.enableAutomaticLock ? .on : .off
        timeoutSlider.doubleValue = settings.inactivityTimeout
        passwordProtectionSwitch.state = settings.enablePasswordProtection ? .on : .off
        maxAttemptsStepper.integerValue = settings.maxFailedAttempts
        lockoutDurationSlider.doubleValue = settings.lockoutDuration
    }
    
    private func updateUIState() {
        let settings = UserSettings.shared

        // Matrix Labels
        animationSpeedLabel.stringValue = String(format: "%.1fx", animationSpeedSlider.doubleValue)
        densityLabel.stringValue = "\(Int(densitySlider.doubleValue * 100))%"
        
        // Security Labels & Controls
        timeoutLabel.stringValue = "Lock after \(Int(timeoutSlider.doubleValue)) seconds"
        maxAttemptsLabel.stringValue = "\(maxAttemptsStepper.integerValue) attempts"
        updateLockoutLabel(duration: lockoutDurationSlider.doubleValue)
        
        let autoLockEnabled = automaticLockSwitch.state == .on
        timeoutSlider.isEnabled = autoLockEnabled
        
        let passwordProtectionEnabled = passwordProtectionSwitch.state == .on
        passwordField.isEnabled = passwordProtectionEnabled
        setPasswordButton.isEnabled = passwordProtectionEnabled
        maxAttemptsStepper.isEnabled = passwordProtectionEnabled
        lockoutDurationSlider.isEnabled = passwordProtectionEnabled
    }
    
    // MARK: - Actions

    @IBAction func settingDidChange(_ sender: Any) {
        // This generic action will trigger for most controls.
        // We update the model based on which control sent the action.
        
        if let control = sender as? NSControl {
            let settings = UserSettings.shared
            
            switch control {
            // General
            case launchAtLoginSwitch:
                LaunchAtLogin.isEnabled = (launchAtLoginSwitch.state == .on)
            case hideFromDockSwitch:
                settings.hideFromDock = (hideFromDockSwitch.state == .on)
                showRestartAlert()
            case startMinimizedSwitch:
                settings.startMinimized = (startMinimizedSwitch.state == .on)
            
            // Matrix
            case characterColorWell:
                settings.matrixCharacterColor = characterColorWell.color
            case animationSpeedSlider:
                settings.matrixAnimationSpeed = animationSpeedSlider.doubleValue
            case densitySlider:
                settings.matrixDensity = densitySlider.doubleValue
            case soundEffectsSwitch:
                settings.matrixSoundEffects = (soundEffectsSwitch.state == .on)
                
            // Security
            case automaticLockSwitch:
                settings.enableAutomaticLock = (automaticLockSwitch.state == .on)
                // Trigger monitoring start/stop
                let notificationName = settings.enableAutomaticLock ? Notifications.startMonitoring : Notifications.stopMonitoring
                NotificationCenter.default.post(name: notificationName, object: nil)
            case timeoutSlider:
                settings.inactivityTimeout = timeoutSlider.doubleValue
            case passwordProtectionSwitch:
                settings.enablePasswordProtection = (passwordProtectionSwitch.state == .on)
            case maxAttemptsStepper:
                settings.maxFailedAttempts = maxAttemptsStepper.integerValue
            case lockoutDurationSlider:
                settings.lockoutDuration = lockoutDurationSlider.doubleValue
            default:
                break
            }
        }
        
        updateUIState()
        NotificationCenter.default.post(name: Notifications.settingsDidChange, object: nil)
    }

    @IBAction func setPasswordClicked(_ sender: NSButton) {
        let password = passwordField.stringValue
        if !password.isEmpty {
            UserSettings.shared.setPassword(password)
            passwordField.stringValue = "" // Clear field after setting
            showPasswordConfirmation()
        }
    }
    
    // MARK: - Helper Methods
    
    private func updateLockoutLabel(duration: TimeInterval) {
        let minutes = Int(duration / 60)
        lockoutDurationLabel.stringValue = "\(minutes) min lockout"
    }
    
    private func showRestartAlert() {
        let alert = NSAlert()
        alert.messageText = "Restart Required"
        alert.informativeText = "Hiding the app from the Dock requires a restart of MatrixLocker to take effect."
        alert.addButton(withTitle: "OK")
        alert.runModal()
    }
    
    private func showPasswordConfirmation() {
        let alert = NSAlert()
        alert.messageText = "Password Set"
        alert.informativeText = "Your new password has been securely saved."
        alert.alertStyle = .informational
        alert.addButton(withTitle: "OK")
        alert.runModal()
    }
}
```

-----

### **Updated File: `AppDelegate.swift`**

**(Replace in `MatrixLocker/`)**

```swift
import Cocoa

@main
class AppDelegate: NSObject, NSApplicationDelegate {

    var lockScreenWindowController: NSWindowController?
    private var activityMonitor: ActivityMonitor?
    var statusItem: NSStatusItem?
    var settingsWindowController: NSWindowController?

    func applicationDidFinishLaunching(_ aNotification: Notification) {
        setupSystemTray()
        
        activityMonitor = ActivityMonitor()

        if UserSettings.shared.enableAutomaticLock {
            NotificationCenter.default.post(name: Notifications.startMonitoring, object: nil)
        }
        
        NotificationCenter.default.addObserver(self, selector: #selector(showLockScreen), name: Notifications.userDidBecomeInactive, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(settingsDidChange), name: Notifications.settingsDidChange, object: nil)
    }

    func applicationWillTerminate(_ aNotification: Notification) {
        activityMonitor?.stopMonitoring()
        NotificationCenter.default.removeObserver(self)
    }
    
    func applicationShouldHandleReopen(_ sender: NSApplication, hasVisibleWindows flag: Bool) -> Bool {
        if !flag {
            showSettings()
        }
        return true
    }

    @objc func showLockScreen() {
        guard lockScreenWindowController == nil else { return }

        SoundManager.shared.play(effect: .lock)
        
        let storyboard = NSStoryboard(name: "Main", bundle: nil)
        guard let vc = storyboard.instantiateController(withIdentifier: "LockScreenViewController") as? LockScreenViewController else {
            fatalError("Could not find LockScreenViewController in Storyboard.")
        }
        
        let lockWindow = NSWindow(contentViewController: vc)
        lockWindow.styleMask = [.borderless]
        lockWindow.isOpaque = true
        lockWindow.backgroundColor = .black
        lockWindow.level = .screenSaver
        lockWindow.setFrame(NSScreen.main!.frame, display: true, animate: false)
        
        let wc = NSWindowController(window: lockWindow)
        lockScreenWindowController = wc
        vc.delegate = self
        
        wc.showWindow(self)
    }
    
    @objc func settingsDidChange() {
        // Refresh the status item to reflect new settings
        updateStatusMenu()
    }
    
    // MARK: - System Tray Setup
    
    private func setupSystemTray() {
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.squareLength)
        statusItem?.button?.image = NSImage(systemSymbolName: "grid", accessibilityDescription: "MatrixLocker")
        updateStatusMenu()
    }
    
    private func updateStatusMenu() {
        let menu = NSMenu()
        let settings = UserSettings.shared
        
        // Status Item
        let statusTitle = settings.enableAutomaticLock ? "Monitoring Active (\(Int(settings.inactivityTimeout))s)" : "Monitoring Disabled"
        let statusItem = NSMenuItem(title: statusTitle, action: nil, keyEquivalent: "")
        statusItem.isEnabled = false
        menu.addItem(statusItem)
        
        menu.addItem(NSMenuItem.separator())

        // Quick Actions
        menu.addItem(NSMenuItem(title: "Lock Screen Now", action: #selector(lockScreenNow), keyEquivalent: "l"))
        
        let toggleTitle = settings.enableAutomaticLock ? "Disable Monitoring" : "Enable Monitoring"
        menu.addItem(NSMenuItem(title: toggleTitle, action: #selector(toggleMonitoring), keyEquivalent: ""))

        menu.addItem(NSMenuItem(title: "Activate in 10s", action: #selector(activateNow), keyEquivalent: ""))
        
        menu.addItem(NSMenuItem.separator())
        
        // Settings
        menu.addItem(NSMenuItem(title: "Settings...", action: #selector(showSettings), keyEquivalent: ","))
        
        menu.addItem(NSMenuItem.separator())

        // Quit
        menu.addItem(NSMenuItem(title: "Quit MatrixLocker", action: #selector(NSApplication.terminate(_:)), keyEquivalent: "q"))
        
        statusItem?.menu = menu
        updateStatusItemIcon()
    }
    
    private func updateStatusItemIcon() {
        if let button = statusItem?.button {
            let isEnabled = UserSettings.shared.enableAutomaticLock
            button.contentTintColor = isEnabled ? UserSettings.shared.matrixCharacterColor : .tertiaryLabelColor
        }
    }
    
    // MARK: - Menu Actions
    
    @objc private func lockScreenNow() {
        showLockScreen()
    }
    
    @objc private func toggleMonitoring() {
        UserSettings.shared.enableAutomaticLock.toggle()
        let notificationName = UserSettings.shared.enableAutomaticLock ? Notifications.startMonitoring : Notifications.stopMonitoring
        NotificationCenter.default.post(name: notificationName, object: nil)
        updateStatusMenu()
    }
    
    @objc private func activateNow() {
        NotificationCenter.default.post(name: Notifications.activateNow, object: nil)
    }

    @objc private func showSettings() {
        if settingsWindowController == nil {
            let storyboard = NSStoryboard(name: "Main", bundle: nil)
            guard let vc = storyboard.instantiateController(withIdentifier: "SettingsViewController") as? SettingsViewController else {
                return
            }
            let window = NSWindow(contentViewController: vc)
            window.title = "MatrixLocker Settings"
            window.styleMask = [.titled, .closable, .miniaturizable]
            settingsWindowController = NSWindowController(window: window)
        }
        
        settingsWindowController?.showWindow(self)
        NSApp.activate(ignoringOtherApps: true)
    }
}

// MARK: - LockScreenDelegate
extension AppDelegate: LockScreenDelegate {
    func didUnlockScreen() {
        lockScreenWindowController?.close()
        lockScreenWindowController = nil
        // Restart monitoring if it was enabled
        if UserSettings.shared.enableAutomaticLock {
            activityMonitor?.startMonitoring()
        }
    }
}
```